#+AUTHOR:
* Design notes
** Requirements
*** Requirement
Allow creating a document out of any combination of resources from any
supported (in translations.json) language in any order.
*** Requirement
Produce PDF final document.
*** Requirement
If generation of PDF document takes longer than X threshold of time,
then return a message to the user giving link where document will
eventually be found. E.g., display message to user in interface, say
after a cache miss on document request, or, via email. Details to be
determined.
*** Requirement
Handle TN, TA, TW, TQ, ULB, UDB resource requests. Later perhaps also
OBS, etc..
** JSON document generation request design for web client (BIEL)
Currently the JSON looks like this, for example:

#+begin_src js
{ "resources":
  { "lang_code": "am", "resource_type": "ulb", "resource_code": "gen" },
  { "lang_code": "lpx", "resource_type": "tn", "resource_code": "exo" },
  ...
}
#+end_src

Each element in the JSON dictionary represents a resource. The whole
dictionary represents all the resources you want in the final typeset
document in the order you want them. Note that last point: the order.
That could of course be changed, but I am for now making an assumption
that BIEL's wizard would compose a JSON document generation request
having resources in the order the user requested the document's
resources to be represented.
*** Example request from =test_flask.py=
Example python client request using resources JSON dictionary to submit an
API call to generate a document composed of resources. I imagine =BIEL=
would make this client request, instead, in Javascript.

#+begin_src python
import json
import requests

payload = {}
payload["resources"] = [
    {"lang_code": "am",
     "resource_type": "ulb",
     "resource_code": "gen"},
    {"lang_code": "erk-x-erakor",
     "resource_type": "reg",
     "resource_code": "eph"},
    {"lang_code": "ml",
     "resource_type": "ulb",
     "resource_code": "tit"},
    {"lang_code": "mr",
     "resource_type": "udb",
     "resource_code": "mrk"},
]


res = requests.post("http://localhost:5005/api/v1/document", json=json.dumps(payload))
if res.ok:
    print(res.json())
#+end_src

** Interactions at a high level

# #+begin_src plantuml :file wa_design_sequence_diagram1.png :exports results
# UI_biel -> flask_app.document_endpoint: JSON document resources request
# flask_app.document_endopint -> DocumentGenerator: instantiate DocumentGenerator\npassing resources from request
# #+end_src

#+RESULTS:
[[file:wa_design_sequence_diagram1.png]]


=DocumentGenerator= passes back a JSON dict containing any messaging and
the eventual location of the generated document for display to the
requesting user (by =BIEL=), or the document itself (depending on how
long it takes to generate).

# #+begin_src plantuml :file wa_design_sequence_diagram2.png :exports results
# DocumentGenerator -> DocumentGenerator: generate document request key unique to set of resources requested, e.g., a request for two resources: ml-ulb-gen-en-ulb-wa-gen.
# DocumentGenerator -> ResourceFactory: using Factory Method design pattern, for each resource, instantiate Resource subclasses from document request based on type
# DocumentGenerator <- ResourceFactory: Return either USFMResource, TAResource, TNResource, TQResource, TWResource
# Resource ->  Resource: find location
# Resource ->  ResourceJsonLookup: lookup: find URL for resource
# Resource <-- ResourceJsonLookup: return URL
# Resource ->  Resource: get (clone or download) associated files from URL
# Resource <-- Resource: remember locations of acquired files
# Resource -> Resource: initialize other instance vars of resource based on acquired files
# Resource -> Resource: get content, i.e., convert Resource's content to HTML
# DocumentGenerator -> DocumentGenerator: for each resource, concatenate each Resources' HTML
# DocumentGenerator -> DocumentGenerator: enclose concatenated HTML bodies in an HTML and body element with styling
# DocumentGenerator -> DocumentGenerator: convert HTML to PDF using pandoc
# #+end_src

#+RESULTS:
[[file:wa_design_sequence_diagram2.png]]


A problem with the old design was that it had one class, =TnConverter=,
doing all the work. This monolithic design resulted in copious
conditional logic in order to deal with handling different types of
resources differently, e.g., USFM files, translation notes, etc..

This new version of the design has extracted logic paths unique to
each resource type and relocated them into Resource subclasses,
created via a factory method (=ResourceFactory=). These subclasses share
a clean interface: =find_location=, =get_files=, =initialize_properties=,
=get_content=. The work of =find_location= is delegated to
=ResourceJsonLookup= for all instances. =get_files= is also common to all
subclasses and not specialized from the =Resource= superclass.
Specialization in each subclass happens in the =initialize_properties=
and =get_content= methods.

This new design has also replaced the design of passing around a
dictionary within =DocumentGenerator=. Each resource that is part of a
single document request is now fully reified into its own object and
=DocumentGenerator= maintains a collection of these Resource instances.

=DocumentGenerator= also now maintains a unique key for each particular
collection of resources in the document generation request. This will
make it possible in a future design to simply lookup, if it exists, an
already finalized and generated document if one with the same
resources and order has been requested in the past. This should
greatly improve UX experience due to cutting out all the document
generation processing time.

# #+begin_src plantuml :file wa_design_class_diagram_resources.png :exports results
# Resource *-- ResourceJsonLookup
# Resource : find_location()
# Resource : get_files()
# Resource : {abstract} initialize_properties()
# Resource : {abstract} get_content()
# note top of Resource: Partially abstract superclass that handles behavior common to all resources
# Resource <|-- USFMResource
# ' USFMResource : +find_location()
# ' USFMResource : +get_files()
# USFMResource : +initialize_properties()
# USFMResource : +get_content()
# Resource <|-- TResource
# TResource : +_discover_layout()
# TResource : +_convert_md2html()
# note top of TResource: superclass that handles behavior common to all non-USFM resources
# TResource <|-- TNResource
# ' TNResource : +find_location()
# ' TNResource : +get_files()
# TNResource : +ihitialize_properties()
# TNResource : +get_content()
# TResource <|-- TAResource
# ' TAResource : +find_location()
# ' TAResource : +get_files()
# TAResource : +ihitialize_properties()
# TAResource : +get_content()
# TResource <|-- TQResource
# ' TQResource : +find_location()
# ' TQResource : +get_files()
# TQResource : +ihitialize_properties()
# TQResource : +get_content()
# TResource <|-- TWResource
# ' TWResource : +find_location()
# ' TWResource : +get_files()
# TWResource : +ihitialize_properties()
# TWResource : +get_content()
# #+end_src

#+RESULTS:
[[file:wa_design_class_diagram_resources.png]]


The interface for ResourceLookup has not changed since the last
design, but some of the underlying implementation details have that
are not relevant to this design document.

# #+begin_src plantuml :file wa_design_class_diagram.png :exports results
# ResourceLookup <|-- ResourceJsonLookup
# ResourceLookup : {abstract} lookup()
# note top of ResourceLookup : Abstract superclass which exists only\nfor documentation and design looking\nforward to ResourceGraphQLLookup.\nIt is definitely not necessary for the system to work
# ResourceJsonLookup : +lookup()
# ResourceLookup <|-- ResourceGraphQLLookup
# note bottom of ResourceGraphQLLookup : Does not currently exist,\n but could replace ResourceJsonLookup one day.\nWith this design, call sites could largely\nremain unchanged.
# ResourceGraphQLLookup : +lookup()
# #+end_src

#+RESULTS:
[[file:wa_design_class_diagram.png]]


As mentioned above a =DocumentGenerator= accepts a document generation
request composed of resources. =DocumentGenerator= instantiates the
appropriate =Resource= subclass based on the resource type. Each
=Resource= instance composes one =ResourceJsonLookup= to which it delegates
lookup tasks.

# #+begin_src plantuml :file wa_design_class_diagram2.png :exports results
# DocumentGenerator o-- Resource
# Resource *-- ResourceJsonLookup
# note top of DocumentGenerator : This used to be called TnConverter.
# note bottom of Resource : Already discussed above, e.g., USFMResource, TAResource, TNResource, TQResource, or TWResource
# note bottom of ResourceJsonLookup : This is where the translations.json API is queried
# #+end_src

#+RESULTS:
[[file:wa_design_class_diagram2.png]]

** What works currently
1. Making a request for document generation to the web service (flask) running.
2. The resources that comprise the document generation request can handle a book-level of request granularity at present.
3. Resources are found and provisioned to disk (but not yet typeset
   into a final document -- this is mainly where my efforts are focused
   currently).
Files involved: =flask_app.py=, =resource_lookup.py=,
=document_generator.py=, =resource.py= (and =config.py=, =file_utils.py=,
=url_utils.py=, and my clone of =USFM-Tools= repo).
** Docker container
There isn't much to say about the docker container except that it
provides the runtime environment, obviously. The only significant new
detail is that flask can be specified to run on a particular IP and
port (seen in =docker-compose.yaml=) which =BIEL= will know and use when
submitting requests.

In a later iteration toward the end, flask will presumably be load
balanced. Further, to protect its pool of workers from being tied up
by long running client requests from =BIEL=, one can adopt an
architecture such as the one described in the next paragraph.

=nginx= in front of =gnunicorn= in front of flask could be put in place to
handle load balancing incoming front end requests from =BIEL=. To learn
why you might do something like that please see this [[https://stackoverflow.com/questions/20766684/what-benefit-is-added-by-using-gunicorn-nginx-flask#20766961][stackoverflow
answer]]

I am not bothering myself with this at all right now, just mentioning
it. There are other architectures that could be used when we get
there.
** How to run a demo for yourself
*** Set up for demos
1. Get the tools repo:

#+begin_src shell
git clone https://github.com/linearcombination/tools.git
#+end_src

2. Install the required python packages. I use pipenv, but you can do it however you prefer:

I do:

#+begin_src shell
pipenv --python /path/to/python/3.8.5 # I think this will work if you point it at any python3 though.
#+end_src

then

#+begin_src shell
pipenv shell # get in the pipenv, virtualenv, conda, whatever shell
#+end_src

then

#+begin_src shell
# You can do just this one if you don't want to bother with virtual
# envs. With pipenv as you probably know, this will make a virtual env
# only install of the requirements only accessible after: pipenv
# shell.
pip install -r requirements.txt
#+end_src

*** Run demo outside docker container (faster)

**** For =resource_lookup.py=:
In pipenv or virtualenv shell:

#+begin_src shell
python -m test_resource_lookup
#+end_src

You should see a lot of output resulting from the tests doing various
lookups into the translations.json file after first acquiring it if
needed.
**** For =document_generator.py= (used to be named =export_md_to_pdf.py=):

#+begin_src shell
python -m test_document_generator
#+end_src

This will go a long ways, but eventually die before generating a final
document.

**** For testing the web service front end do:

    1. First, run the web server

#+begin_src shell
./run_flask.sh
#+end_src

    2. In a pipenv or virtualenv shell do:

#+begin_src shell
python -m test_flask
#+end_src

This will run HTTP web client tests that exercise the web service.

*** For demo inside the docker container (slower):

- Get the docker container source:

#+begin_src shell
git clone https://github.com/linearcombination/Interleaved_Resources_Generator
#+end_src

- cd into the container repo root dir from step 1a above.

- Symbolically link the tools directory from earlier into the root of the container repo you cloned earlier:

#+begin_src shell
ln -s /path/to/tools .
#+end_src

- Build the container:

#+begin_src shell
./build.sh # This will take a little while to build the container. When it completes building it will automatically start the web server front end.
#+end_src

If you want to rebuild the container after a git pull do:

#+begin_src shell
docker ps -a # This will get the ID, first column, that you need to be able to remove the container for a rebuild
docker rm ID # ID here is the ID from the previous step
#+end_src

then repeat 3 again.

- Submit client requests (you need to be in the tools repo root directory as before):

#+begin_src shell
python -m test_flask
#+end_src

** (Bonus/optional material) Convenience web service endpoints for BIEL UI to call (if desired)
In the interest of good user experience, it will be important that
=BIEL= only request resources that actually exist (as defined by
=translations.json=).

I've provided a couple of web app endpoints from which =BIEL= can
request data in order to populate its dropdown menu's in =BIEL='s
document request wizard.

*** Example client call to get all language codes (sans language name)
Example client call from =test_flask.py=:

#+begin_src python
import json
import requests

res = requests.get("http://localhost:5005/api/v1/language_codes")
if res.ok:
print(res.json()) # Presumably, BIEL'll display it in a drop down menu or similar.
#+end_src
*** Get all language code, language name pairs
Example client call from =test_flask.py=.

#+begin_src python
import json
import requests

res = requests.get("http://localhost:5005/api/v1/language_codes_and_names")
if res.ok:
    print(res.json()) # Presumably, BIEL'll display it in a drop down menu or similar.
#+end_src

** Oddities - differences from the norm in resources I've found
These are oddities that are not currently handled, either at all or
totally, either by the original system or the current system.

Examples:

| Language code | Resource type | Resource code | Oddity                                                      |
|---------------+---------------+---------------+-------------------------------------------------------------|
| ml            | tn            | any           | zip contains a manifest.yaml per usual, but the translation |
|               |               |               | notes are not in markdown they are tsv files.               |
| erk-x-erakor  | reg           | any           | manifest.json rather than manifest.txt or manifest.yaml.    |
|               |               |               | manifest.json has different structure and keys.             |

*** TODO for Craig: a license for the =Interleaved_Resources_Generator= project
I need a license emailed to me that I can check in to the repo. Or you
can send me a link to the license and I'll get it there. Thanks!
# ** (Optional to read) Some rough ideas about how to request smaller granularity than book
# If chapter is the finest granularity of a resource request, the JSON
# could be:
# #+begin_src js
# { "resources":
#   { "lang_code": "am",
#     "resource_type": "ulb",
#     "resource_code": "gen",
#     "book_chapter": "1" }, // Get just chapter 1
#   { "lang_code": "lpx",
#     "resource_type": "tn",
#     "resource_code": "exo",
#     "book_chapter": "" }, // Get the whole book
#   ...
# }
# #+end_src


# If verse is the finest granularity of a resource request, the JSON could be:
# #+begin_src js
# { "resources":
#   { "lang_code": "am",
#     "resource_type": "ulb",
#     "resource_code": "gen",
#     "book_chapter": "1",
#     "verse_start": "1",
#     "verse_end": "3" }, // Get chapter 1, verse 1-3
#   { "lang_code": "am",
#     "resource_type": "ulb",
#     "resource_code": "gen",
#     "book_chapter": "1",
#     "verse_range": "1-1" }, // Or, Get chapter 1, verse 1
#   { "lang_code": "am",
#     "resource_type": "ulb",
#     "resource_code": "gen",
#     "book_chapter": "1",
#     "verse_range": "1-3" }, // Or, Get chapter 1, verse 1-3
#   { "lang_code": "am",
#     "resource_type": "ulb",
#     "resource_code": "gen",
#     "book_chapter": "1",
#     "verse_range": "1-3,5" }, // Or, Get chapter 1, verse 1-3 and verse 5
#   { "lang_code": "lpx",
#     "resource_type": "tn",
#     "resource_code": "exo",
#     "book_chapter": "2" }, // Get chapter 2
#   { "lang_code": "lpx",
#     "resource_type": "tn",
#     "resource_code": "exo",
#     "book_chapter": "" }, // Get the whole book
#   ...
# }
# #+end_src

# As said before, from a user experience perspective, =BIEL= would need to
# know what chapters or verses are available so as not to disappoint the
# user. Nevertheless, the system is being designed to gracefully handle
# such disappointments.
