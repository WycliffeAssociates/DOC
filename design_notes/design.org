#+AUTHOR:
* Design notes
** Requirements
*** Requirement
Allow creating a document out of any combination of resources from any
supported (in translations.json) language.
*** Requirement
Produce PDF final document.
*** Requirement
If generation of PDF document takes longer than X threshold of time,
then return a message to the user giving link where document will
eventually be found. E.g., display message to user in interface, say
after a cache miss on document request, or, via email. Details to be
determined.
*** Requirement
Handle TN, TA, TW, TQ, ULB, UDB resource requests. Later perhaps also
OBS, etc..
** How to run a demo for yourself
*** Get the code
Get the tools repo:

#+begin_src shell
git clone https://github.com/linearcombination/tools.git
#+end_src

Then cd into the tools directory you just creating by cloning.
*** Run demo inside the Docker container:
**** One command to take down old running containers, build the new, and run all tests
#+begin_src shell
make all
#+end_src
**** Or, you can do one thing at a time using multiple Makefile targets
***** Build the container

First take down any running containers from previous runs:

#+begin_src shell
make down
#+end_src

#+begin_src shell
make build
#+end_src
***** Or, build the container the 2+Nth time from scratch

First take down any running containers from previous runs:

#+begin_src shell
make down
#+end_src

then

#+begin_src shell
make build-no-cache
#+end_src

***** Run the tests
#+begin_src shell
make test
#+end_src

**** Run demo outside Docker container
***** Install the required python packages. I use pipenv, but you can do it however you prefer.

First tell pipenv which python to use:
#+begin_src shell
pipenv --python /path/to/python3
#+end_src

then

#+begin_src shell
pipenv shell # get in the pipenv, virtualenv, conda, whatever shell
#+end_src

then

#+begin_src shell
# You can do just this one if you don't want to bother with virtual
# envs. With pipenv as you probably know, this will make a virtual env
# only install of the requirements only accessible after: pipenv
# shell.
pipenv install
#+end_src

then

#+begin_src shell
pip install -e src/
#+end_src

***** Run tests
#+begin_src shell
pytest
#+end_src
** TODO Update this since new code (mostly the same but some changes - more classes): Interactions at a high level

#+begin_src plantuml :file wa_design_sequence_diagram1.png :exports results
UI_biel -> app.document_endpoint: JSON document resources request
app.document_endopint -> DocumentGenerator: instantiate DocumentGenerator\npassing resources from request
#+end_src

#+RESULTS:
[[file:wa_design_sequence_diagram1.png]]


=DocumentGenerator= passes back a JSON dict containing any messaging and
the eventual location of the generated document for display to the
requesting user (by =BIEL=), or the document itself (depending on how
long it takes to generate).

#+begin_src plantuml :file wa_design_sequence_diagram2.png :exports results
DocumentGenerator -> DocumentGenerator: generate document request key unique to set of resources requested, e.g., a request for two resources: ml-ulb-gen-en-ulb-wa-gen.
DocumentGenerator -> ResourceFactory: using Factory Method design pattern, for each resource, instantiate Resource subclasses from document request based on resource type
DocumentGenerator <- ResourceFactory: Return either USFMResource, TAResource, TNResource, TQResource, TWResource
Resource ->  Resource: find location
Resource ->  ResourceJsonLookup: lookup: find URL for resource
Resource <-- ResourceJsonLookup: return URL
Resource ->  Resource: get (clone or download) associated files from URL
Resource <-- Resource: remember locations of acquired files
Resource -> Resource: initialize other instance vars of resource based on acquired files
Resource -> Resource: get content, i.e., convert Resource's content to HTML
DocumentGenerator -> DocumentGenerator: for each resource, concatenate each Resources' HTML
DocumentGenerator -> DocumentGenerator: enclose concatenated HTML bodies in an HTML and body element with styling
DocumentGenerator -> DocumentGenerator: convert HTML to PDF using pandoc
#+end_src

#+RESULTS:
[[file:wa_design_sequence_diagram2.png]]


A problem with the old design was that it had one class, =TnConverter=,
doing all the work. This monolithic design resulted in copious
conditional logic in order to deal with handling different types of
resources differently, e.g., USFM files, translation notes, etc..

This new version of the design has extracted logic paths unique to
each resource type and relocated them into Resource subclasses,
created via a factory method (=ResourceFactory=). These subclasses share
a clean interface: =find_location=, =get_files=, =initialize_properties=,
=get_content=. The work of =find_location= is delegated to
=ResourceJsonLookup= for all instances. =get_files= is also common to all
subclasses and not specialized from the =Resource= superclass.
Specialization in each subclass happens in the =initialize_properties=
and =get_content= methods.

This new design has also replaced the design of passing around a
dictionary within =DocumentGenerator=. Each resource that is part of a
single document request is now fully reified into its own object and
=DocumentGenerator= maintains a collection of these Resource instances.

=DocumentGenerator= also now maintains a unique key for each particular
collection of resources in the document generation request. This will
make it possible in a future design to simply lookup, if it exists, an
already finalized and generated document if one with the same
resources and order has been requested in the past. This should
greatly improve UX experience due to cutting out all the document
generation processing time.

#+begin_src plantuml :file wa_design_class_diagram_resources.png :exports results
Resource *-- ResourceJsonLookup
Resource : find_location()
Resource : get_files()
Resource : {abstract} initialize_properties()
Resource : {abstract} get_content()
note top of Resource: Partially abstract superclass that handles behavior common to all resources
Resource <|-- USFMResource
' USFMResource : +find_location()
' USFMResource : +get_files()
USFMResource : +initialize_properties()
USFMResource : +get_content()
Resource <|-- TResource
TResource : +_discover_layout()
TResource : +_convert_md2html()
note top of TResource: superclass that handles behavior common to all non-USFM resources
TResource <|-- TNResource
' TNResource : +find_location()
' TNResource : +get_files()
TNResource : +ihitialize_properties()
TNResource : +get_content()
TResource <|-- TAResource
' TAResource : +find_location()
' TAResource : +get_files()
TAResource : +ihitialize_properties()
TAResource : +get_content()
TResource <|-- TQResource
' TQResource : +find_location()
' TQResource : +get_files()
TQResource : +ihitialize_properties()
TQResource : +get_content()
TResource <|-- TWResource
' TWResource : +find_location()
' TWResource : +get_files()
TWResource : +ihitialize_properties()
TWResource : +get_content()
#+end_src

#+RESULTS:
[[file:wa_design_class_diagram_resources.png]]


The interface for ResourceLookup has not changed since the last
design, but some of the underlying implementation details have that
are not relevant to this design document.

#+begin_src plantuml :file wa_design_class_diagram.png :exports results
ResourceLookup <|-- ResourceJsonLookup
ResourceLookup : {abstract} lookup()
note top of ResourceLookup : Abstract superclass which exists only\nfor documentation and design looking\nforward to ResourceGraphQLLookup.\nIt is definitely not necessary for the system to work
ResourceJsonLookup : +lookup()
ResourceLookup <|-- ResourceGraphQLLookup
note bottom of ResourceGraphQLLookup : Does not currently exist,\n but could replace ResourceJsonLookup one day.\nWith this design, call sites could largely\nremain unchanged.
ResourceGraphQLLookup : +lookup()
#+end_src

#+RESULTS:
[[file:wa_design_class_diagram.png]]


As mentioned above a =DocumentGenerator= accepts a document generation
request composed of resources. =DocumentGenerator= instantiates the
appropriate =Resource= subclass based on the resource type. Each
=Resource= instance composes one =ResourceJsonLookup= to which it delegates
lookup tasks.

#+begin_src plantuml :file wa_design_class_diagram2.png :exports results
DocumentGenerator o-- Resource
Resource *-- ResourceJsonLookup
note top of DocumentGenerator : This used to be called TnConverter.
note bottom of Resource : Already discussed above, e.g., USFMResource, TAResource, TNResource, TQResource, or TWResource
note bottom of ResourceJsonLookup : This is where the translations.json API is queried
#+end_src

#+RESULTS:
[[file:wa_design_class_diagram2.png]]

** Docker container
There isn't much to say about the docker container except that it
provides the runtime environment, obviously. The only significant new
detail is that fastapi can be specified to run on a particular IP and
port (seen in =docker-compose.yaml=) which =BIEL= will know and use when
submitting requests.

In a later iteration toward the end, Fastapi will presumably be load
balanced. Further, to protect its pool of workers from being tied up
by long running client requests from =BIEL=, one can adopt an
architecture such as the one described in the next paragraph.

=nginx= in front of =gnunicorn= in front of fastapi could be put in place to
handle load balancing incoming front end requests from =BIEL=. To learn
why you might do something like that please see this [[https://stackoverflow.com/questions/20766684/what-benefit-is-added-by-using-gunicorn-nginx-flask#20766961][stackoverflow answer]]

I am not bothering myself with this at all right now, just mentioning
it. There are other architectures that could be used when we get
there.
** (Bonus/optional material) Convenience web service endpoints for BIEL UI to call (if desired)
In the interest of good user experience, it will be important that
=BIEL= only request resources that actually exist (as defined by
=translations.json=).

I've provided a few web app endpoints from which =BIEL= can
request data in order to populate its dropdown menu's in =BIEL='s
document request wizard.

You can see those by looking at ../tests/e2e/test_biel_helper.py
** Oddities - differences from the norm in resources I've found
These are oddities that are not currently handled, either at all or
totally, either by the original system or the current system.

Examples:

| Language code | Resource type | Resource code | Oddity                                                      |
|---------------+---------------+---------------+-------------------------------------------------------------|
| ml            | tn            | any           | zip contains a manifest.yaml per usual, but the translation |
|               |               |               | notes are not in markdown they are tsv files.               |
| erk-x-erakor  | reg           | any           | manifest.json rather than manifest.txt or manifest.yaml.    |
|               |               |               | manifest.json has different structure and keys.             |
| en            | tn-wa         | any           | translations.json only lists links to PDFs                  |

** Handling different manifests
Lang,

In our previous meeting, I mentioned how different repos and projects
had different manifests, and that they have evolved since the
beginning of the project.

Here is an example of some code that is version-aware and migrates
older versions of manifests to the most recent one. I hope it may be
of some use to you, even if only to highlight what some of the
differences between the versions are:

https://github.com/Bible-Translation-Tools/BTT-Writer-Desktop/blob/master/src/js/migrator.js


Craig Oliver
